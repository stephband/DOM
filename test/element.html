<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="author" content="stephband" />
    <meta name="description" content="" />
    <meta name="viewport" content="width=device-width" />

    <title>Custom Element Test</title>

    <script title="debug">
    window.DEBUG = true;
    </script>
</head>

<body>
    <header>
        <h1>Custom Element Test</h1>
    </header>

    <section title="Before registration" id="before-test">
        <h2>HTML before element registration</h2>

        <test-element count="1">
            <p>Slotted content</p>
        </test-element>
    </section>

    <script type="module">
    import test    from "../../fn/modules/test.js";
    import element from "../modules/element.js";

    test("Create element", [
        // Before registration
        'construct',
        'attribute-1',
        'connect-1',

        // After registration
        'construct',
        'attribute-2',
        'connect-2',

        // Asynchronous
        // We cannot guarantee the order of these. Ã‡a me vexe un peu.
        'slotchange-1',
        'slotchange-2',
        'load-1',
        'load-2',

        // document.createElement()
        'construct',
        'attribute-3',
        'connect-3',
        'slotchange-3',
        'load-3',

        // element.cloneNode()
        'construct',
        'attribute-3',
        // .setAttribute()
        'attribute-4',
        'connect-4',
        // .setAttribute()
        'attribute-5',
        'slotchange-5',
        'load-5',

        // template.cloneNode()
        'construct',
        'attribute-6',
        'connect-6',
        'slotchange-6',
        'load-6',
    ], (expects, done) => {
        // Register the element.
        const TestElement = element('test-element', {
            construct: function(shadow) {
                expects('construct');

                const slot = document.createElement('slot');
                shadow.append(slot);

                slot.addEventListener('slotchange', (e) => {
                    expects('slotchange-' + this.count, 'Cannot guarantee order of load and slotchange - try running again with an empty cache');
                });
            },

            connect: function() {
                expects('connect-' + this.count);
            },

            load: function() {
                expects('load-' + this.count, 'Cannot guarantee order of load and slotchange - try running again with an empty cache');

                if (this.count === '6') {
                    done();
                }
            }
        }, {
            count: {
                attribute: function(value) {
                    this.count = value;
                    expects('attribute-' + this.count);
                }
            }
        }, '../../bolt/elements/html.css');

        function isTestElement(element) {
            return TestElement.prototype.isPrototypeOf(element);
        }

        setTimeout(function() {
            // Construct
            const elem1   = document.createElement('test-element');
            const slotted = document.createElement('p');
            slotted.innerHTML = 'Slotted content';
            elem1.append(slotted);
            elem1.setAttribute('count', '3');

            // Add to DOM
            document.getElementById('create-test').append(elem1);

            // Clone
            setTimeout(function() {
                const elem2 = elem1.cloneNode(true);
                // TODO: This is failing to update elem2.count, and I have no
                // idea why. Are we not upgraded yet? I suspect something wrong
                // with my assumptions in element() ... TODO!
                elem2.setAttribute('count', '4');

                document.getElementById('clone-test').append(elem2);

                // This DOES update elem2.count
                elem2.setAttribute('count', '5');
            }, 300);
        }, 300);

        setTimeout(function() {
            // Construct
            const template = document.getElementById('element-template');
            const fragment = template.content.cloneNode(true);

            // Add to DOM
            template.after(fragment);
        }, 900);
    });
    </script>

    <section title="After registration" id="after-test">
        <h2>HTML after element registration</h2>

        <test-element count="2">
            <p>Slotted content</p>
        </test-element>
    </section>

    <section title="document.createElement()" id="create-test">
        <h2>Created by document.createElement()</h2>
    </section>

    <section title="element.cloneNode()" id="clone-test">
        <h2>Created by element.cloneNode()</h2>
    </section>

    <section title="template.content.cloneNode()" id="template-test">
        <h2>Created by template.content.cloneNode()</h2>

        <template id="element-template">
            <test-element count="6">
                <p>Slotted content</p>
            </test-element>
        </template>
    </section>
</body>
